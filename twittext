#!/usr/bin/env python
#-*- coding: utf-8 -*-

##################################################
# Twittext
# - http://www.techno-st.net/wiki/Twittext
##################################################

import twitter
import curses, curses.wrapper
import locale
import signal
import urllib2
import string
import sys
import re
import htmlentitydefs

# config file
from config import *

def start(stdcur):
    stdcur.timeout(DELAY)
    stdcur.scrollok(0)
    curses.use_default_colors()

    curses.start_color()
    curses.init_pair(1, curses.COLOR_RED, -1)
    curses.init_pair(2, curses.COLOR_GREEN, -1)
    curses.init_pair(3, curses.COLOR_BLUE, -1)    

    force_reload = False

    while True:
        (Y, X) = stdcur.getmaxyx()
        
        curses.noecho()
        curses.curs_set(0)
        
        stdcur.clear()
        stdcur.addstr(0, 0, "Loading Timeline...")
        stdcur.refresh()
        
        try:
            if pytw_ver >= 0.6:
                tl = api.GetFriendsTimeline(count = (Y - 2))
            else:
                # for old version api
                tl = api.GetFriendsTimeline()
        except urllib2.HTTPError, e:
            if e.code == 401:
                curses.endwin()
                sys.stderr.write("Error: Authentication Failed\n")
                exit()
            elif e.code == 400:
                curses.endwin()
                sys.stderr.write("Error: Twitter API Rate Limit.\n")
                exit()
            elif e.code / 100 == 5:
                stdcur.addstr(1, 0, "Error: Twitter over capacity...")
                stdcur.addstr(2, 0, "Press any key to continue.")
                stdcur.refresh()
                stdcur.getch()
                continue
            else:
                raise e
        except urllib2.URLError:
            curses.endwin()
            sys.stderr.write("Error: Can't connect twitter.\n")
            exit()
        
        if force_reload:
            api.SetCacheTimeout(cachetime)
            force_reload = False
        
        stdcur.clear()
        stdcur.addstr(0, 0, "Post?: ")
        stdcur.addstr(" " * (X - 8), curses.A_UNDERLINE)
        header = " (@%s) [Twittext] =" % USER
        stdcur.addstr(
            1, 0,
            "=" * (X - len(header)) + header)
        stdcur.refresh()
        
        tl_list = show_timeline(tl, stdcur, Y, X)
        
        c = stdcur.getch(0, 7)
        curses.flushinp()
        stdcur.clrtoeol()
        
        if c == curses.KEY_DOWN:
            # status select mode
            stdcur.move(2, 0)
            postmsg = post_select_mode(tl_list, stdcur, stdcur, Y, X)
        elif c == 0x0a or c == curses.KEY_ENTER: # Enter
            # post status
            curses.echo()
            curses.curs_set(1)
            postmsg = stdcur.getstr(0, 7).decode('utf-8')
        elif c == 0x72: # r
            # force reload
            api.SetCacheTimeout(0)
            force_reload = True
            continue
        elif c == 0x40: # @
            # show replies
            repwin = stdcur.subwin(2, 0)
            repwin.clear()
            repwin.addstr(0, 0, "Get Replies...")
            repwin.refresh()
            
            try:
                reps = api.GetReplies()
                repwin.clear()
                rep_list = show_timeline(reps, repwin, Y, X, 0)
                
                repwin.move(0, 0)
                repwin.refresh()
                postmsg = post_select_mode(rep_list, repwin, stdcur, Y, X)
            except urllib2.HTTPError, e:
                if e.code == 400:
                    stdcur.clear()
                    stdcur.addstr(0, 0, "Error: Twitter API Rate Limit...")
                    stdcur.addstr(1, 0, "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()
                    continue
                elif e.code / 100 == 5:
                    stdcur.clear()
                    stdcur.addstr(0, 0, "Error: Twitter over capacity...")
                    stdcur.addstr(1, 0, "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()
                    continue
                else:
                    raise e
        elif c == 0x75: # u
            # show user status
            curses.echo()
            curses.curs_set(1)
            stdcur.addstr(0, 0, "User?: @")
            username = stdcur.getstr(0, 8).decode('utf-8')
            curses.noecho()
            curses.curs_set(0)
            
            usrwin = stdcur.subwin(2, 0)
            usrwin.clear()
            usrwin.addstr(0, 0, "Get @%s Timeline..." % username)
            usrwin.refresh()

            try:
                try:
                    usrtl = api.GetUserTimeline(username)
                except urllib2.HTTPError, e:
                    if e.code == 404:
                        stdcur.clear()
                        stdcur.addstr(0, 0, 
                                      "Error: User @%s NotFound..." % username)
                        stdcur.addstr(1, 0, "Press any key to continue.")
                        stdcur.refresh()
                        stdcur.getch()
                        continue
                    else:
                        raise e
                
                usrwin.clear()            
                usr_list = show_timeline(usrtl, usrwin, Y, X, 0)

                usrwin.move(0, 0)
                usrwin.refresh()
                postmsg = post_select_mode(usr_list, usrwin, stdcur, Y, X)
            except urllib2.HTTPError, e:
                if e.code == 400:
                    stdcur.clear()
                    stdcur.addstr(1, 0, "Error: Twitter API Rate Limit...")
                    stdcur.addstr(2, 0, "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()
                    continue
                elif e.code / 100 == 5:
                    stdcur.clear()
                    stdcur.addstr(1, 0, "Error: Twitter over capacity...")
                    stdcur.addstr(2, 0, "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()
                    continue
                else:
                    raise e
        
        elif c == 0x71: # q
            # quit
            exit()
        elif c == -1:
            # nothing input
            continue
        else:
            # other input
            continue
        
        stdcur.clear()
        curses.noecho()
        stdcur.refresh()
       
        if not postmsg == None and not postmsg == "":
            api.SetCacheTimeout(0)
            force_reload = True

            stdcur.addstr(0, 0, "Posting Status...")
            stdcur.refresh()
            
            try:
                if isinstance(postmsg, tuple):
                    (message, reply_to) = postmsg

                    if pytw_ver >= 0.6:
                        ret = api.PostUpdate(message[:140], reply_to)
                    else:
                        ret = api.PostUpdate(message[:140])
                else:
                    postmsg += FOOTER
                    ret = api.PostUpdate(postmsg[:140])

                stdcur.clear()
                stdcur.refresh()
            except urllib2.HTTPError, e:
                if e.code == 400:
                    stdcur.addstr(1, 0, "Error: Twitter API Rate Limit...")
                    stdcur.addstr(2, 0, "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()
                    continue
                elif e.code / 100 == 5:
                    stdcur.addstr(1, 0, "Error: Twitter over capacity...")
                    stdcur.addstr(2, 0, "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()
                    continue
                else:
                    raise e

def show_timeline(tl, win, Y, X, starty = 2):
    ret = []
    i = starty
    
    win.move(0, 0)
    win.refresh()
    (sy, sx) = curses.getsyx()
    sy = sy + i
    
    for s in tl:
        if s.user.screen_name == USER:
            win.attrset(curses.color_pair(3))
        elif s.in_reply_to_screen_name == USER:
            win.attrset(curses.color_pair(1) | curses.A_BOLD)
        elif s.text.find("@%s" % USER) != -1:
            if s.text.find("@%s" % USER) == 0:
                win.attrset(curses.color_pair(1))
            else:
                win.attrset(curses.color_pair(2))
        else:
            win.attrset(0)
            
        win.addstr(i, 0, "[%7s] " % (s.user.screen_name[0:7]))

        sss = split_text(replace_htmlentity(s.text), X - 10)

        ii = 0
        for ss in sss:
            if sy < Y - 1:
                win.addstr(i, 10, ss.encode("utf-8"))
            else:
                # lower left char bug fix
                win.addstr(i, 10, ss[:len(ss) - 1].encode("utf-8"))

            if ii > 0:
                # for post_select_mode() (gets first char attr)
                win.addch(i, 0, ' ')
            
            ret.append(s)
            
            ii += 1
            i += 1
            sy += 1
            
            if sy >= Y:
                break
        
        if sy >= Y:
            break
    
    win.attrset(0)
    win.refresh()
    
    return ret

def post_select_mode(tl_list, win, stdcur, Y, X):
    (ny, nx) = win.getyx()
    starty = ny

    win.move(0, 0)
    win.refresh()
    (sy, sx) = curses.getsyx()
    maxy = Y - sy
    
    win.move(ny, nx)
    
    while True:
        (ny, nx) = win.getyx()
        attr = win.inch(ny, 0) & 0xffffff00
        selstr = win.instr(ny, 0)
        
        if ny < maxy - 1:
            win.addstr(ny, 0, selstr,
                       attr | curses.A_STANDOUT)
        else:
            win.addstr(ny, 0, selstr[:len(selstr) - 1],
                       attr | curses.A_STANDOUT)
        
        win.move(ny, 0)
        win.refresh()
        (ty, tx) = win.getyx()
        
        curses.flushinp()
        c = stdcur.getch(0, 7)

        win.move(ty, tx)
        win.refresh()

        if len(tl_list) <= ny - starty:
            target = None
        else:
            target = tl_list[ny - starty]

        postmsg = None
        
        if c == curses.KEY_DOWN:
            if ny < maxy - 1:
                v = 1
            else:
                v = 0
        elif c == curses.KEY_UP:
            if ny > starty:
                v = -1
            else:
                v = 0
        elif c == 0x0a or c == curses.KEY_ENTER: # Enter
            # Reply
            if target == None:
                continue

            curses.echo()
            stdcur.addstr(0, 0, "Reply: ")
            stdcur.clrtoeol()

            reply_to = target.id
            
            replymsg = "@%s " % target.user.screen_name
            curses.curs_set(1)
            stdcur.addstr(0, 7, replymsg)
            tmpstr = stdcur.getstr(
                0, 7 + len(replymsg)).decode('utf-8')
            
            if not tmpstr == "": # empty reply?
                replymsg += tmpstr
                postmsg = (replymsg, reply_to)
            
            break # this is ok
        elif c == 0x72: # r
            # ReTweet
            if target == None:
                continue
            
            curses.echo()
            stdcur.addstr(0, 0, "ReTweet: ")
            stdcur.clrtoeol()
            
            reply_to = target.id
            
            curses.curs_set(1)
            tmpstr = stdcur.getstr(0, 9).decode('utf-8')
            
            if tmpstr == "":
                rtmsg = "RT @%s: %s" % (
                    target.user.screen_name, target.text)
            else:
                rtmsg = "%s RT @%s: %s" % (
                    tmpstr, target.user.screen_name, target.text)
            
            stdcur.move(0, 0)
            stdcur.clrtoeol()
            stdcur.addstr(0, 0, "OK? (Y/n): ")
            
            if not stdcur.getch(0, 11) == 0x6e: # Y?
                postmsg = rtmsg
 
            break # this is ok
        elif c == 0x75: # u
            # show user timeline
            if target == None:
                continue

            usrwin = stdcur.subwin(2, 0)
            usrwin.clear()
            usrwin.addstr(0, 0,
                          "Get @%s Timeline..." % target.user.screen_name)
            usrwin.refresh()
            
            usrtl = api.GetUserTimeline(target.user.id)
            usrwin.clear()
            usr_list = show_timeline(usrtl, usrwin, Y, X, 0)
            
            usrwin.move(0, 0)
            usrwin.refresh()

            postmsg = post_select_mode(usr_list, usrwin, stdcur, Y, X)
            break
        elif c == 0x64: # d
            # Destroy Post
            if target == None:
                continue

            stdcur.move(0, 0)
            stdcur.clrtoeol()
            stdcur.addstr(0, 0, "Destroy? (Y/n): ")
         
            if not stdcur.getch(0, 11) == 0x6e: # n
                stdcur.clear()
                stdcur.addstr(0, 0, "Waiting...")
                stdcur.refresh()
                
                try:
                    api.DestroyStatus(target.id)
                except urllib2.HTTPError, e:
                    if e.code == 403:
                        stdcur.clear()
                        stdcur.addstr(0, 0, "Error: Oops! Can't Destroy...")
                        stdcur.addstr(1, 0, "Press any key to continue.")
                        stdcur.refresh()
                        stdcur.getch()
                    else:
                        raise e
            
            break # this is ok
        elif c == 0x1b: # Esc
            break
        else:
            continue
        
        attr = (win.inch(ny, 0) & 0xffffff00) ^ curses.A_STANDOUT
        selstr = win.instr(ny, 0)
        
        if ny < maxy - 1:
            win.addstr(ny, 0, selstr, attr)
        else:
            win.addstr(ny, 0, selstr[:len(selstr) - 1], attr)
        
        win.move(ny + v, 0)
        
        win.refresh()
    
    return postmsg

def split_text(s, w):
    i = 0
    ss = ""
    sss = []
    
    for c in s:
        if c == "\n":
            continue
        
        if 0x00 <= ord(c) <= 0x7f:
            i += 1
        else:
            i += 2
        
        ss += c
        
        if i >= w - 1:
            if len(sss) == 0:
                sss = [ss]
            else:
                sss.append(ss)
            
            ss = ""
            i = 0
    
    if not ss == "":
        sss.append(ss)
    
    return sss

def replace_htmlentity(string):
    amp = string.find('&')
    if amp == -1:
        return string
    
    entity = re.compile("&([A-Za-z]+);")
    entity_match = entity.findall(string)

    for name in entity_match:
        c = htmlentitydefs.name2codepoint[name]
        string = string.replace("&%s;" % name, unichr(c))
    
    return string

def quit_me(signum = None, frame = None):
    exit()


signal.signal(signal.SIGINT, quit_me)
locale.setlocale(locale.LC_ALL, "")
api = twitter.Api(username = USER, password = PASS)
pytw_ver = float(twitter.__version__[:3])

if(pytw_ver >= 0.6):
    api.SetCacheTimeout(cachetime)
    #api.SetSource("Twitext")

curses.wrapper(start)
