#!/usr/bin/env python
#-*- coding: utf-8 -*-

##################################################
# Twittext
# - http://www.techno-st.net/wiki/Twittext
##################################################

import twitter
import curses
import curses.wrapper
import curses.textpad
import locale
import signal
import urllib2
import string

# config file
from config import *

cachetime = 30

def start(stdcur):
    stdcur.timeout(DELAY)
    curses.use_default_colors()
    force_reload = False
    stdcur.scrollok(0)
    
    while True:
        (Y, X) = stdcur.getmaxyx()

        curses.noecho()
        curses.curs_set(0)
        stdcur.addstr(0, 0, "Loading Timeline...")
        stdcur.refresh()
        
        try:
            tl = api.GetFriendsTimeline(count = (Y - 2))
        except TypeError:
            tl = api.GetFriendsTimeline()
        except urllib2.HTTPError, e:
            if e.code == 401:
                curses.endwin()
                print "Error: Authentication Failed"
                exit()
            elif e.code / 100 == 5:
                stdcur.addstr(1, 0, "[Twitter Error (%d)]" % e.code)
                continue
            else:
                curses.endwin()
                print "Error: %s", e
                exit()
        except urllib2.URLError:
            curses.endwin()
            print "Error: Can't connect twitter."
            exit()
        
        if force_reload:
            api.SetCacheTimeout(cachetime)
            force_reload = False

        stdcur.addstr(0, 0, "Post?: ")
        stdcur.addstr(" " * (X - 8), curses.A_STANDOUT)
        
        header = " (@%s) [Twittext] =" % USER
        stdcur.addstr(
            1, 0,
            "=" * (X - len(header)) + header)

        tl_list = show_timeline(tl, stdcur, Y, X)
        
        c = stdcur.getch(0, 7)
        
        if c == curses.KEY_DOWN:
            stdcur.addstr(0, 7, " " * (X - 8))
            stdcur.move(2, 0)
            postmsg = post_select_mode(tl_list, stdcur, stdcur, Y, X)
        elif c == 0x0a or c == curses.KEY_ENTER: # Enter
            curses.echo()
            curses.curs_set(1)
            stdcur.addstr(" " * (X - 8))
            postmsg = stdcur.getstr(0, 7).decode('utf-8')
        elif c == 0x72: # r
            api.SetCacheTimeout(0)
            force_reload = True
            postmsg = None
        elif c == 0x40: # @
            # show replies
            repwin = stdcur.subwin(2, 0)
            repwin.clear()
            
            reps = api.GetReplies()
            rep_list = show_timeline(reps, repwin, Y, X, 0)
            
            repwin.move(0, 0)
            repwin.refresh()
            postmsg = post_select_mode(rep_list, repwin, stdcur, Y, X)
        elif c == 0x71: # q
            exit()
        elif c == -1:
            postmsg = None
        else:
            postmsg = None
            continue
        
        stdcur.clear()
        curses.noecho()

        stdcur.addstr(0, 0, "Posting Status...")
        stdcur.refresh()
        
        if not postmsg == None and not postmsg == "":
            try:
                if isinstance(postmsg[1], long):
                    (message, reply_to) = postmsg

                    if pytw_ver >= 0.6:
                        ret = api.PostUpdate(message[:140], reply_to)
                    else:
                        ret = api.PostUpdate(message[:140])
                else:
                    ret = api.PostUpdate((postmsg + FOOTER)[:140])
            except urllib2.HTTPError, e:
                if e.code / 100 == 5:
                    stdcur.addstr(1, 0, 
                                  "Error: Twitter over capacity...")
                    stdcur.addstr(2, 0,
                                  "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()
        
        stdcur.clear()

def show_timeline(tl, win, Y, X, starty = 2):
    ret = []
    i = starty
    
    win.move(0, 0)
    win.refresh()
    (sy, sx) = curses.getsyx()
    sy = sy + i
    
    for s in tl:
        win.addstr(
            i, 0, "[%7s] " % (
                s.user.screen_name[0:7]))
        
        sss = split_text(s.text, X - 10)
        
        for ss in sss:
            if sy < Y - 1:
                win.addstr(i, 10, ss.encode("utf-8"))
            else:
                win.addstr(i, 10, ss[:len(ss) - 1].encode("utf-8"))
            
            ret.append(s)
            
            i += 1
            sy += 1
            
            if sy >= Y:
                break
        
        if sy >= Y:
            break
    
    win.refresh()
    
    return ret

def post_select_mode(tl_list, win, stdcur, Y, X):
    (ny, nx) = win.getyx()
    starty = ny

    win.move(0, 0)
    win.refresh()
    (sy, sx) = curses.getsyx()
    maxy = Y - sy
    
    win.move(ny, nx)
    
    while True:
        (ny, nx) = win.getyx()
        selstr = win.instr(ny, 0)
        
        if ny < maxy - 1:
            win.addstr(ny, 0, selstr, curses.A_STANDOUT)
        else:
            win.addstr(ny, 0, selstr[:len(selstr) - 1], curses.A_STANDOUT)
        
        win.move(ny, 0)
        win.refresh()
        (ty, tx) = win.getyx()

        curses.flushinp()
        c = stdcur.getch(0, 7)

        win.move(ty, tx)
        win.refresh()

        if len(tl_list) <= ny - starty:
            target = None
        else:
            target = tl_list[ny - starty]

        postmsg = None
        
        if c == curses.KEY_DOWN:
            if ny < maxy - 1:
                v = 1
            else:
                v = 0
        elif c == curses.KEY_UP:
            if ny > starty:
                v = -1
            else:
                v = 0
        elif c == 0x0a or c == curses.KEY_ENTER: # Enter
            # Reply
            if target == None:
                continue

            curses.echo()
            stdcur.addstr(0, 0, "Reply: ")            

            reply_to = target.id
            
            replymsg = "@%s " % target.user.screen_name
            curses.curs_set(1)
            stdcur.addstr(0, 7, replymsg)
            tmpstr = stdcur.getstr(
                0, 7 + len(replymsg)).decode('utf-8')
            
            if not tmpstr == "": # empty reply?
                replymsg += tmpstr
                postmsg = (replymsg, reply_to)
 
            break # this is ok
        elif c == 0x72: # r
            # ReTweet
            if target == None:
                continue

            curses.echo()
            stdcur.addstr(0, 0, "ReTweet: ")
            
            reply_to = target.id
            
            curses.curs_set(1)
            tmpstr = stdcur.getstr(0, 9).decode('utf-8')
            
            if tmpstr == "":
                rtmsg = "RT @%s: %s" % (target.user.screen_name, target.text)
            else:
                rtmsg = "%s RT @%s: %s" % (tmpstr, target.user.screen_name, target.text)
            
            stdcur.move(0, 0)
            stdcur.clrtoeol()
            stdcur.addstr(0, 0, "OK? (Y/n): ")
            
            if not stdcur.getch(0, 11) == 0x6e: # Y?
                postmsg = rtmsg
 
            break # this is ok
        elif c == 0x75: # u
            # show user timeline
            if target == None:
                continue

            usrwin = stdcur.subwin(2, 0)
            usrwin.clear()
            
            usrtl = api.GetUserTimeline(target.user.id)
            usr_list = show_timeline(usrtl, usrwin, Y, X, 0)
            
            usrwin.move(0, 0)
            usrwin.refresh()

            postmsg = post_select_mode(usr_list, usrwin, stdcur, Y, X)
            break
        elif c == 0x64: # d
            # Destroy Post
            if target == None:
                continue

            stdcur.move(0, 0)
            stdcur.clrtoeol()
            stdcur.addstr(0, 0, "Destroy? (Y/n): ")
            
            if not stdcur.getch(0, 11) == 0x6e: # n
                try:
                    api.DestroyStatus(target.id)
                except urllib2.HTTPError:
                    stdcur.clear()
                    stdcur.addstr(0, 0, 
                                  "Error: Oops! Can't Destroy...")
                    stdcur.addstr(1, 0,
                                  "Press any key to continue.")
                    stdcur.refresh()
                    stdcur.getch()

            break # this is ok
        elif c == 0x1b: # Esc
            break
        else:
            continue
        
        selstr = win.instr(ny, 0)
        
        if ny < maxy - 1:
            win.addstr(ny, 0, selstr, curses.A_NORMAL)
        else:
            win.addstr(ny, 0, selstr[:len(selstr) - 1], curses.A_NORMAL)
        
        win.move(ny + v, 0)
        
        win.refresh()
    
    return postmsg

def split_text(s, w):
    i = 0
    ss = ""
    sss = []
    
    for c in s:
        if c == "\n":
            continue
        
        if 0x00 <= ord(c) <= 0x7f:
            i += 1
        else:
            i += 2

        ss += c
        
        if i >= w - 1:
            if len(sss) == 0:
                sss = [ss]
            else:
                sss.append(ss)
            
            ss = ""
            i = 0
    
    if not ss == "":
        sss.append(ss)

    return sss

def debug_print(txt):
    curses.endwin()
    print txt

def quit_me(signum = None, frame = None):
    exit()

signal.signal(signal.SIGINT, quit_me)
locale.setlocale(locale.LC_ALL, "")
api = twitter.Api(username = USER, password = PASS)
pytw_ver = float(twitter.__version__[:3])

if(pytw_ver >= 0.6):
    api.SetCacheTimeout(cachetime)
    #api.SetSource("Twitext")

curses.wrapper(start)
